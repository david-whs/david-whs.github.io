import{Vertex}from "./vertex.js";import{TEXTSTYLE}from "./constants.js";import{Edge}from "./edge.js";export class Flownetwork{constructor(){this.vertices=[];this.lastId=this.vertices.length}addVertex(clickPosition){const linkColor=getComputedStyle(document.body).getPropertyValue("--r-link-color");const id=this.lastId;const label=new PIXI.Text(id,TEXTSTYLE);label.x=clickPosition.x-12;label.y=clickPosition.y-22;const shape=new PIXI.Graphics();shape.beginFill(Number.parseInt("0x"+linkColor.slice(1)));shape.drawCircle(clickPosition.x,clickPosition.y,30);shape.endFill();const vertex=new Vertex(id,label,shape,clickPosition.x,clickPosition.y);shape.interactive=true;this.vertices.push(vertex);this.lastId+=1;return vertex}isLastVertex(vertex){return vertex===this.vertices[this.vertices.length-1]}deleteVertex(id){const deletedVertex=this.vertices.find((vertex)=>vertex.id===id);const wasLastVertex=this.isLastVertex(deletedVertex);this.vertices.forEach((vertex)=>{vertex.edges=vertex.edges.filter((edge)=>edge.to!==deletedVertex)});this.vertices=this.vertices.filter((vertex)=>vertex!==deletedVertex);if(wasLastVertex){let maxPossibleFlow=0;if(this.vertices.length>1){const newLast=this.vertices[this.vertices.length-1];this.vertices.forEach((vertex)=>{vertex.edges.forEach((edge)=>{if(edge.to===newLast){maxPossibleFlow+=Number.parseInt(edge.capacity)}})})}document.getElementById("maxPossibleFlow").innerText=maxPossibleFlow}}addEdge(from,to){const shape=new PIXI.Graphics();shape.lineStyle(4,0xFFFFFF,1);shape.moveTo(from.x,from.y);shape.lineTo(to.x,to.y);shape.closePath();shape.endFill();let capacity=prompt("Geben Sie eine ganzzahlige Kapazität ein:");while(isNaN(Number.parseInt(capacity))){if(!capacity){return}capacity=prompt("Geben Sie eine ganzzahlige Kapazität ein:")}const text=`0/${ capacity }`;const label=new PIXI.Text(text,{fill:0xFFFFFF,fontFamily:'Helvetica',fontSize:30});label.x=((from.x+to.x)/2);label.y=(from.y+to.y)/2;const labelBackground=new PIXI.Graphics();labelBackground.beginFill(0x0c0c0c);labelBackground.drawRect(label.x,label.y,text.length*15,35);labelBackground.endFill();labelBackground.interactive=true;const edge=new Edge(from,to,capacity,shape,label,labelBackground);from.edges.push(edge);return edge}getAugmentingPath(){let queue=[];let explored=[];let childParent=new Map();queue.push(this.source);explored.push(this.source);while(queue.length>0){let currentVertex=queue.shift();if(currentVertex===this.target){currentVertex=this.target;let path=[];do{let edge=childParent.get(currentVertex).getEdge(currentVertex);path.push(edge);currentVertex=childParent.get(currentVertex)}while(currentVertex!=this.source);return path.reverse()}const edgesFromCurrentVertex=currentVertex.edges;for(let i=0;i<edgesFromCurrentVertex.length;i+=1){const e=edgesFromCurrentVertex[i];if(e.hasRemainingCapacity()&&!explored.includes(e.to)){queue.push(e.to);explored.push(e.to);childParent.set(e.to,e.from)}}}return[]}}